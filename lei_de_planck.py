# -*- coding: utf-8 -*-
"""Lei de Planck

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1efuIlsLj5g25K0mB3_WXTI7GFnwOr1nM
"""

import math
from scipy.integrate import quad
import serial

h = 6.626e-34  # Constante de Planck
k = 1.381e-23  # Constante de Boltzmann
c = 299792458  # Velocidade da luz
o = 5.6703744e-8  # Constante de Stefan-Boltzmann

y = 2*math.pi*(k**4)/((h**3)*(c**2)) #Constante extraída da integral da Lei de Planck

#Função que retorna o coeficiente x (hv/kT) da Lei de Planck em função de frequências em THz e da temperatura em Kelvin
def x(v, T):
    return (v * 1e12) * h / (k * T)

#Integral da Lei de Planck simplificada em função do coeficiente x
def planck(x):
    return (x**3) / ((math.e**x) - 1)

#Função que realiza a integral
def integral(v1, v2, T):
    a = x(v1, T)
    b = x(v2, T)
    integral, error = quad(planck, a, b)
    return integral * y * (T**4)

#Lei de Stefan-Boltzmann
def stef_boltz(T):
    return o * (T**4)

#Função que cria uma lista com os valores RGB da temperatura comparando com a Lei de Stefan-Boltzmann
def rgb(T):
    #Realizamos a integral definida em cada faixa luminosa
    integral_r = integral(384, 480, T) #vermelho
    integral_o = integral(480, 510, T) #laranja
    integral_y = integral(510, 530, T) #amarelo
    integral_g = integral(530, 610, T) #verde
    integral_c = integral(610, 618, T) #ciano
    integral_b = integral(618, 665, T) #azul
    integral_v = integral(665, 789, T) #violeta

    stef_boltz_T = stef_boltz(T)

    #The parada is the seguinte: para representar todas as cores visíveis no RGB, é necessário transformar todas as cores
    #em um "valor" RGB. Exemplo, o vermelho é obviamente 100% vermelho, mas o laranja é a soma de 50% de vermelho com 50%
    #de verde, o amarelo é a soma de 100% de vermelho com 100% de verde, e assim por diante. Logo temos as configurações,
    #sabendo que a porcentagem se refere a porcentagem da integral de cada cor:

    #Vermelho = 100% vermelho + 50% laranja + 100% amarelo + 25,5% violeta
    #Verde = 100% verde + 50% laranja + 100% amarelo + 100% ciano
    #Azul = 100% azul + 100% ciano + 100% violeta

    r = (integral_r + integral_o * 0.5 + integral_y + integral_v * 0.255) / stef_boltz_T
    g = (integral_g + integral_o * 0.5 + integral_y + integral_c) / stef_boltz_T
    b = (integral_b + integral_c + integral_v) / stef_boltz_T

    r = round(r * 255)
    g = round(g * 255)
    b = round(b * 255)

    return [r, g, b]

#Objeto da conexão serial. Substitua o X de COMX para o número da porta USB do seu Arduino (exemplo: COM4)
#Você pode descobrir o número da porta na IDE do Arduino
ser = serial.Serial('COMX',9600,timeout=1)

#Função que envia os dados da lista para a porta
def enviar_csv(r, g, b):
    ser.write(f"{r},{g},{b}\n".encode())

#Nessa configuração, os dados são enviadas infinitamente até a conexão serial ser encerrada
while True:
    cor = rgb(5800)
    enviar_csv(cor[0],cor[1],cor[2])